"""
This type stub file was generated by pyright.
"""

import collections

def encode_text(s):
    ...

PDFDocEncoding = ...
def decode_text(b): # -> str:
    ...

class PdfFormatError(RuntimeError):
    """An error that probably indicates a syntactic or semantic error in the
    PDF file structure"""
    ...


def check_format_condition(condition, error_message): # -> None:
    ...

class IndirectReference(collections.namedtuple("IndirectReferenceTuple", ["object_id", "generation"])):
    def __str__(self) -> str:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class IndirectObjectDef(IndirectReference):
    def __str__(self) -> str:
        ...
    


class XrefTable:
    def __init__(self) -> None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def __delitem__(self, key): # -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def keys(self): # -> set[Any]:
        ...
    
    def write(self, f):
        ...
    


class PdfName:
    def __init__(self, name) -> None:
        ...
    
    def name_as_str(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @classmethod
    def from_pdf_stream(cls, data): # -> Self:
        ...
    
    allowed_chars = ...
    def __bytes__(self): # -> bytes:
        ...
    


class PdfArray(list):
    def __bytes__(self): # -> bytes:
        ...
    


class PdfDict(collections.UserDict):
    def __setattr__(self, key, value): # -> None:
        ...
    
    def __getattr__(self, key): # -> struct_time | str:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    


class PdfBinary:
    def __init__(self, data) -> None:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    


class PdfStream:
    def __init__(self, dictionary, buf) -> None:
        ...
    
    def decode(self): # -> Any | bytes:
        ...
    


def pdf_repr(x): # -> bytes:
    ...

class PdfParser:
    """Based on
    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf
    Supports PDF up to 1.4
    """
    def __init__(self, filename=..., f=..., buf=..., start_offset=..., mode=...) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    
    def start_writing(self): # -> None:
        ...
    
    def close_buf(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def seek_end(self): # -> None:
        ...
    
    def write_header(self): # -> None:
        ...
    
    def write_comment(self, s): # -> None:
        ...
    
    def write_catalog(self): # -> IndirectReference:
        ...
    
    def rewrite_pages(self): # -> None:
        ...
    
    def write_xref_and_trailer(self, new_root_ref=...): # -> None:
        ...
    
    def write_page(self, ref, *objs, **dict_obj): # -> IndirectReference:
        ...
    
    def write_obj(self, ref, *objs, **dict_obj): # -> IndirectReference:
        ...
    
    def del_root(self): # -> None:
        ...
    
    @staticmethod
    def get_buf_from_file(f): # -> mmap | Literal[b""]:
        ...
    
    def read_pdf_info(self): # -> None:
        ...
    
    def next_object_id(self, offset=...): # -> IndirectReference:
        ...
    
    delimiter = ...
    delimiter_or_ws = ...
    whitespace = ...
    whitespace_or_hex = ...
    whitespace_optional = ...
    whitespace_mandatory = ...
    whitespace_optional_no_nl = ...
    newline_only = ...
    newline = ...
    re_trailer_end = ...
    re_trailer_prev = ...
    def read_trailer(self): # -> None:
        ...
    
    def read_prev_trailer(self, xref_section_offset): # -> None:
        ...
    
    re_whitespace_optional = ...
    re_name = ...
    re_dict_start = ...
    re_dict_end = ...
    @classmethod
    def interpret_trailer(cls, trailer_data): # -> dict[Any, Any]:
        ...
    
    re_hashes_in_name = ...
    @classmethod
    def interpret_name(cls, raw, as_text=...): # -> str | Any | bytes:
        ...
    
    re_null = ...
    re_true = ...
    re_false = ...
    re_int = ...
    re_real = ...
    re_array_start = ...
    re_array_end = ...
    re_string_hex = ...
    re_string_lit = ...
    re_indirect_reference = ...
    re_indirect_def_start = ...
    re_indirect_def_end = ...
    re_comment = ...
    re_stream_start = ...
    re_stream_end = ...
    @classmethod
    def get_value(cls, data, offset, expect_indirect=..., max_nesting=...):
        ...
    
    re_lit_str_token = ...
    escaped_chars = ...
    @classmethod
    def get_literal_string(cls, data, offset): # -> tuple[bytes, int]:
        ...
    
    re_xref_section_start = ...
    re_xref_subsection_start = ...
    re_xref_entry = ...
    def read_xref_table(self, xref_section_offset):
        ...
    
    def read_indirect(self, ref, max_nesting=...):
        ...
    
    def linearize_page_tree(self, node=...): # -> list[Any]:
        ...
    


