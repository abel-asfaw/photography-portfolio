"""
This type stub file was generated by pyright.
"""

from collections.abc import MutableMapping
from fractions import Fraction
from numbers import Rational
from . import ImageFile

logger = ...
READ_LIBTIFF = ...
WRITE_LIBTIFF = ...
IFD_LEGACY_API = ...
STRIP_SIZE = ...
II = ...
MM = ...
IMAGEWIDTH = ...
IMAGELENGTH = ...
BITSPERSAMPLE = ...
COMPRESSION = ...
PHOTOMETRIC_INTERPRETATION = ...
FILLORDER = ...
IMAGEDESCRIPTION = ...
STRIPOFFSETS = ...
SAMPLESPERPIXEL = ...
ROWSPERSTRIP = ...
STRIPBYTECOUNTS = ...
X_RESOLUTION = ...
Y_RESOLUTION = ...
PLANAR_CONFIGURATION = ...
RESOLUTION_UNIT = ...
TRANSFERFUNCTION = ...
SOFTWARE = ...
DATE_TIME = ...
ARTIST = ...
PREDICTOR = ...
COLORMAP = ...
TILEWIDTH = ...
TILELENGTH = ...
TILEOFFSETS = ...
TILEBYTECOUNTS = ...
SUBIFD = ...
EXTRASAMPLES = ...
SAMPLEFORMAT = ...
JPEGTABLES = ...
YCBCRSUBSAMPLING = ...
REFERENCEBLACKWHITE = ...
COPYRIGHT = ...
IPTC_NAA_CHUNK = ...
PHOTOSHOP_CHUNK = ...
ICCPROFILE = ...
EXIFIFD = ...
XMP = ...
JPEGQUALITY = ...
IMAGEJ_META_DATA_BYTE_COUNTS = ...
IMAGEJ_META_DATA = ...
COMPRESSION_INFO = ...
COMPRESSION_INFO_REV = ...
OPEN_INFO = ...
MAX_SAMPLESPERPIXEL = ...
PREFIXES = ...
_load_dispatch = ...
_write_dispatch = ...
class IFDRational(Rational):
    """Implements a rational class where 0/0 is a legal value to match
    the in the wild use of exif rationals.

    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used
    """
    __slots__ = ...
    def __init__(self, value, denominator=...) -> None:
        """
        :param value: either an integer numerator, a
        float/rational/other number, or an IFDRational
        :param denominator: Optional integer denominator
        """
        ...
    
    @property
    def numerator(self): # -> int | Any:
        ...
    
    @property
    def denominator(self): # -> int:
        ...
    
    def limit_rational(self, max_denominator): # -> tuple[int | Any, Literal[0]] | tuple[int | Any, int | Any]:
        """

        :param max_denominator: Integer, the maximum denominator value
        :returns: Tuple of (numerator, denominator)
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __getstate__(self): # -> list[Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    __add__ = ...
    __radd__ = ...
    __sub__ = ...
    __rsub__ = ...
    __mul__ = ...
    __rmul__ = ...
    __truediv__ = ...
    __rtruediv__ = ...
    __floordiv__ = ...
    __rfloordiv__ = ...
    __mod__ = ...
    __rmod__ = ...
    __pow__ = ...
    __rpow__ = ...
    __pos__ = ...
    __neg__ = ...
    __abs__ = ...
    __trunc__ = ...
    __lt__ = ...
    __gt__ = ...
    __le__ = ...
    __ge__ = ...
    __bool__ = ...
    __ceil__ = ...
    __floor__ = ...
    __round__ = ...
    if hasattr(Fraction, "__int__"):
        __int__ = ...


class ImageFileDirectory_v2(MutableMapping):
    """This class represents a TIFF tag directory.  To speed things up, we
    don't decode tags unless they're asked for.

    Exposes a dictionary interface of the tags in the directory::

        ifd = ImageFileDirectory_v2()
        ifd[key] = 'Some Data'
        ifd.tagtype[key] = TiffTags.ASCII
        print(ifd[key])
        'Some Data'

    Individual values are returned as the strings or numbers, sequences are
    returned as tuples of the values.

    The tiff metadata type of each item is stored in a dictionary of
    tag types in
    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v2.tagtype`. The types
    are read from a tiff file, guessed from the type added, or added
    manually.

    Data Structures:

        * ``self.tagtype = {}``

          * Key: numerical TIFF tag number
          * Value: integer corresponding to the data type from
            :py:data:`.TiffTags.TYPES`

          .. versionadded:: 3.0.0

    'Internal' data structures:

        * ``self._tags_v2 = {}``

          * Key: numerical TIFF tag number
          * Value: decoded data, as tuple for multiple values

        * ``self._tagdata = {}``

          * Key: numerical TIFF tag number
          * Value: undecoded byte string from file

        * ``self._tags_v1 = {}``

          * Key: numerical TIFF tag number
          * Value: decoded data in the v1 format

    Tags will be found in the private attributes ``self._tagdata``, and in
    ``self._tags_v2`` once decoded.

    ``self.legacy_api`` is a value for internal use, and shouldn't be changed
    from outside code. In cooperation with
    :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`, if ``legacy_api``
    is true, then decoded tags will be populated into both ``_tags_v1`` and
    ``_tags_v2``. ``_tags_v2`` will be used if this IFD is used in the TIFF
    save routine. Tags should be read from ``_tags_v1`` if
    ``legacy_api == true``.

    """
    def __init__(self, ifh=..., prefix=..., group=...) -> None:
        """Initialize an ImageFileDirectory.

        To construct an ImageFileDirectory from a real file, pass the 8-byte
        magic header to the constructor.  To only set the endianness, pass it
        as the 'prefix' keyword argument.

        :param ifh: One of the accepted magic headers (cf. PREFIXES); also sets
              endianness.
        :param prefix: Override the endianness of the file.
        """
        ...
    
    prefix = ...
    offset = ...
    legacy_api = ...
    @legacy_api.setter
    def legacy_api(self, value):
        ...
    
    def reset(self): # -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def named(self): # -> dict[Any, Any]:
        """
        :returns: dict of name|key: value

        Returns the complete tag dictionary, with named tags where possible.
        """
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, tag): # -> tuple[Any] | tuple[Any, ...] | bytes:
        ...
    
    def __contains__(self, tag): # -> bool:
        ...
    
    def __setitem__(self, tag, value): # -> None:
        ...
    
    def __delitem__(self, tag): # -> None:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    @_register_loader(1, 1)
    def load_byte(self, data, legacy_api=...):
        ...
    
    @_register_writer(1)
    def write_byte(self, data): # -> bytes:
        ...
    
    @_register_loader(2, 1)
    def load_string(self, data, legacy_api=...):
        ...
    
    @_register_writer(2)
    def write_string(self, value): # -> bytes:
        ...
    
    @_register_loader(5, 8)
    def load_rational(self, data, legacy_api=...): # -> tuple[tuple[Any, Any] | IFDRational, ...]:
        ...
    
    @_register_writer(5)
    def write_rational(self, *values): # -> bytes:
        ...
    
    @_register_loader(7, 1)
    def load_undefined(self, data, legacy_api=...):
        ...
    
    @_register_writer(7)
    def write_undefined(self, value): # -> bytes:
        ...
    
    @_register_loader(10, 8)
    def load_signed_rational(self, data, legacy_api=...): # -> tuple[tuple[Any, Any] | IFDRational, ...]:
        ...
    
    @_register_writer(10)
    def write_signed_rational(self, *values): # -> bytes:
        ...
    
    def load(self, fp):
        ...
    
    def tobytes(self, offset=...): # -> bytes:
        ...
    
    def save(self, fp):
        ...
    


class ImageFileDirectory_v1(ImageFileDirectory_v2):
    """This class represents the **legacy** interface to a TIFF tag directory.

    Exposes a dictionary interface of the tags in the directory::

        ifd = ImageFileDirectory_v1()
        ifd[key] = 'Some Data'
        ifd.tagtype[key] = TiffTags.ASCII
        print(ifd[key])
        ('Some Data',)

    Also contains a dictionary of tag types as read from the tiff image file,
    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v1.tagtype`.

    Values are returned as a tuple.

    ..  deprecated:: 3.0.0
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    tags = ...
    tagdata = ...
    tagtype: dict
    @classmethod
    def from_v2(cls, original): # -> Self:
        """Returns an
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`
        instance with the same data as is contained in the original
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`
        instance.

        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`

        """
        ...
    
    def to_v2(self): # -> ImageFileDirectory_v2:
        """Returns an
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`
        instance with the same data as is contained in the original
        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`
        instance.

        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`

        """
        ...
    
    def __contains__(self, tag): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __setitem__(self, tag, value): # -> None:
        ...
    
    def __getitem__(self, tag): # -> tuple[Any] | tuple[Any, ...] | bytes:
        ...
    


ImageFileDirectory = ImageFileDirectory_v1
class TiffImageFile(ImageFile.ImageFile):
    format = ...
    format_description = ...
    _close_exclusive_fp_after_loading = ...
    def __init__(self, fp=..., filename=...) -> None:
        ...
    
    @property
    def n_frames(self):
        ...
    
    def seek(self, frame): # -> None:
        """Select a given frame as current image"""
        ...
    
    def tell(self): # -> int:
        """Return the current frame number"""
        ...
    
    def getxmp(self): # -> dict[Any, Any] | dict[str, str | dict[str, str] | None]:
        """
        Returns a dictionary containing the XMP tags.
        Requires defusedxml to be installed.

        :returns: XMP tags in a dictionary.
        """
        ...
    
    def get_photoshop_blocks(self): # -> dict[Any, Any]:
        """
        Returns a dictionary of Photoshop "Image Resource Blocks".
        The keys are the image resource ID. For more information, see
        https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1037727

        :returns: Photoshop "Image Resource Blocks" in a dictionary.
        """
        ...
    
    def load(self): # -> None:
        ...
    
    def load_end(self): # -> None:
        ...
    


SAVE_INFO = ...
class AppendingTiffWriter:
    fieldSizes = ...
    Tags = ...
    def __init__(self, fn, new=...) -> None:
        ...
    
    def setup(self): # -> None:
        ...
    
    def finalize(self): # -> None:
        ...
    
    def newFrame(self): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    
    def tell(self): # -> int:
        ...
    
    def seek(self, offset, whence=...): # -> int:
        ...
    
    def goToEnd(self): # -> None:
        ...
    
    def setEndian(self, endian): # -> None:
        ...
    
    def skipIFDs(self): # -> None:
        ...
    
    def write(self, data): # -> int:
        ...
    
    def readShort(self): # -> Any:
        ...
    
    def readLong(self): # -> Any:
        ...
    
    def rewriteLastShortToLong(self, value): # -> None:
        ...
    
    def rewriteLastShort(self, value): # -> None:
        ...
    
    def rewriteLastLong(self, value): # -> None:
        ...
    
    def writeShort(self, value): # -> None:
        ...
    
    def writeLong(self, value): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def fixIFD(self): # -> None:
        ...
    
    def fixOffsets(self, count, isShort=..., isLong=...): # -> None:
        ...
    


