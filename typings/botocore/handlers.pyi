"""
This type stub file was generated by pyright.
"""

"""Builtin event handlers.

This module contains builtin handlers for events emitted by botocore.
"""
logger = ...
REGISTER_FIRST = ...
REGISTER_LAST = ...
VALID_BUCKET = ...
_ACCESSPOINT_ARN = ...
_OUTPOST_ARN = ...
VALID_S3_ARN = ...
S3_SIGNING_NAMES = ...
VERSION_ID_SUFFIX = ...
def handle_service_name_alias(service_name, **kwargs): # -> str | None:
    ...

def add_recursion_detection_header(params, **kwargs): # -> None:
    ...

def escape_xml_payload(params, **kwargs): # -> None:
    ...

def check_for_200_error(response, **kwargs): # -> None:
    ...

def set_operation_specific_signer(context, signing_name, **kwargs): # -> type[UNSIGNED] | LiteralString | Literal['bearer', 'v4a', 'v4'] | None:
    """Choose the operation-specific signer.

    Individual operations may have a different auth type than the service as a
    whole. This will most often manifest as operations that should not be
    authenticated at all, but can include other auth modes such as sigv4
    without body signing.
    """
    ...

def decode_console_output(parsed, **kwargs): # -> None:
    ...

def generate_idempotent_uuid(params, model, **kwargs): # -> None:
    ...

def decode_quoted_jsondoc(value): # -> Any:
    ...

def json_decode_template_body(parsed, **kwargs): # -> None:
    ...

def validate_bucket_name(params, **kwargs): # -> None:
    ...

def sse_md5(params, **kwargs): # -> None:
    """
    S3 server-side encryption requires the encryption key to be sent to the
    server base64 encoded, as well as a base64-encoded MD5 hash of the
    encryption key. This handler does both if the MD5 has not been set by
    the caller.
    """
    ...

def copy_source_sse_md5(params, **kwargs): # -> None:
    """
    S3 server-side encryption requires the encryption key to be sent to the
    server base64 encoded, as well as a base64-encoded MD5 hash of the
    encryption key. This handler does both if the MD5 has not been set by
    the caller specifically if the parameter is for the copy-source sse-c key.
    """
    ...

def disable_signing(**kwargs): # -> type[UNSIGNED]:
    """
    This handler disables request signing by setting the signer
    name to a special sentinel value.
    """
    ...

def add_expect_header(model, params, **kwargs): # -> None:
    ...

class DeprecatedServiceDocumenter:
    def __init__(self, replacement_service_name) -> None:
        ...
    
    def inject_deprecation_notice(self, section, event_name, **kwargs): # -> None:
        ...
    


def document_copy_source_form(section, event_name, **kwargs): # -> None:
    ...

def handle_copy_source_param(params, **kwargs): # -> None:
    """Convert CopySource param for CopyObject/UploadPartCopy.

    This handler will deal with two cases:

        * CopySource provided as a string.  We'll make a best effort
          to URL encode the key name as required.  This will require
          parsing the bucket and version id from the CopySource value
          and only encoding the key.
        * CopySource provided as a dict.  In this case we're
          explicitly given the Bucket, Key, and VersionId so we're
          able to encode the key and ensure this value is serialized
          and correctly sent to S3.

    """
    ...

def inject_presigned_url_ec2(params, request_signer, model, **kwargs): # -> None:
    ...

def inject_presigned_url_rds(params, request_signer, model, **kwargs): # -> None:
    ...

def json_decode_policies(parsed, model, **kwargs): # -> None:
    ...

def parse_get_bucket_location(parsed, http_response, **kwargs): # -> None:
    ...

def base64_encode_user_data(params, **kwargs): # -> None:
    ...

def document_base64_encoding(param): # -> Callable[..., None]:
    ...

def validate_ascii_metadata(params, **kwargs): # -> None:
    """Verify S3 Metadata only contains ascii characters.

    From: http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html

    "Amazon S3 stores user-defined metadata in lowercase. Each name, value pair
    must conform to US-ASCII when using REST and UTF-8 when using SOAP or
    browser-based uploads via POST."

    """
    ...

def fix_route53_ids(params, model, **kwargs): # -> None:
    """
    Check for and split apart Route53 resource IDs, setting
    only the last piece. This allows the output of one operation
    (e.g. ``'foo/1234'``) to be used as input in another
    operation (e.g. it expects just ``'1234'``).
    """
    ...

def inject_account_id(params, **kwargs): # -> None:
    ...

def add_glacier_version(model, params, **kwargs): # -> None:
    ...

def add_accept_header(model, params, **kwargs): # -> None:
    ...

def add_glacier_checksums(params, **kwargs): # -> None:
    """Add glacier checksums to the http request.

    This will add two headers to the http request:

        * x-amz-content-sha256
        * x-amz-sha256-tree-hash

    These values will only be added if they are not present
    in the HTTP request.

    """
    ...

def document_glacier_tree_hash_checksum(): # -> Callable[..., None]:
    ...

def document_cloudformation_get_template_return_type(section, event_name, **kwargs): # -> None:
    ...

def switch_host_machinelearning(request, **kwargs): # -> None:
    ...

def check_openssl_supports_tls_version_1_2(**kwargs): # -> None:
    ...

def change_get_to_post(request, **kwargs): # -> None:
    ...

def set_list_objects_encoding_type_url(params, context, **kwargs): # -> None:
    ...

def decode_list_object(parsed, context, **kwargs): # -> None:
    ...

def decode_list_object_v2(parsed, context, **kwargs): # -> None:
    ...

def decode_list_object_versions(parsed, context, **kwargs): # -> None:
    ...

def convert_body_to_file_like_object(params, **kwargs): # -> None:
    ...

class ParameterAlias:
    def __init__(self, original_name, alias_name) -> None:
        ...
    
    def alias_parameter_in_call(self, params, model, **kwargs): # -> None:
        ...
    
    def alias_parameter_in_documentation(self, event_name, section, **kwargs): # -> None:
        ...
    


class ClientMethodAlias:
    def __init__(self, actual_name) -> None:
        """Aliases a non-extant method to an existing method.

        :param actual_name: The name of the method that actually exists on
            the client.
        """
        ...
    
    def __call__(self, client, **kwargs): # -> Any:
        ...
    


class HeaderToHostHoister:
    """Takes a header and moves it to the front of the hoststring."""
    _VALID_HOSTNAME = ...
    def __init__(self, header_name) -> None:
        ...
    
    def hoist(self, params, **kwargs): # -> None:
        """Hoist a header to the hostname.

        Hoist a header to the beginning of the hostname with a suffix "." after
        it. The original header should be removed from the header map. This
        method is intended to be used as a target for the before-call event.
        """
        ...
    


def inject_api_version_header_if_needed(model, params, **kwargs): # -> None:
    ...

def remove_lex_v2_start_conversation(class_attributes, **kwargs): # -> None:
    """Operation requires h2 which is currently unsupported in Python"""
    ...

def add_retry_headers(request, **kwargs): # -> None:
    ...

def remove_bucket_from_url_paths_from_model(params, model, context, **kwargs): # -> None:
    """Strips leading `{Bucket}/` from any operations that have it.

    The original value is retained in a separate "authPath" field. This is
    used in the HmacV1Auth signer. See HmacV1Auth.canonical_resource in
    botocore/auth.py for details.

    This change is applied to the operation model during the first time the
    operation is invoked and then stays in effect for the lifetime of the
    client object.

    When the ruleset based endpoint resolver is in effect, both the endpoint
    ruleset AND the service model place the bucket name in the final URL.
    The result is an invalid URL. This handler modifies the operation model to
    no longer place the bucket name. Previous versions of botocore fixed the
    URL after the fact when necessary. Since the introduction of ruleset based
    endpoint resolution, the problem exists in ALL URLs that contain a bucket
    name and can therefore be addressed before the URL gets assembled.
    """
    ...

def remove_accid_host_prefix_from_model(params, model, context, **kwargs): # -> None:
    """Removes the `{AccountId}.` prefix from the operation model.

    This change is applied to the operation model during the first time the
    operation is invoked and then stays in effect for the lifetime of the
    client object.

    When the ruleset based endpoint resolver is in effect, both the endpoint
    ruleset AND the service model place the {AccountId}. prefix in the URL.
    The result is an invalid endpoint. This handler modifies the operation
    model to remove the `endpoint.hostPrefix` field while leaving the
    `RequiresAccountId` static context parameter in place.
    """
    ...

def remove_arn_from_signing_path(request, **kwargs): # -> None:
    ...

def customize_endpoint_resolver_builtins(builtins, model, params, context, **kwargs): # -> None:
    """Modify builtin parameter values for endpoint resolver

    Modifies the builtins dict in place. Changes are in effect for one call.
    The corresponding event is emitted only if at least one builtin parameter
    value is required for endpoint resolution for the operation.
    """
    ...

def remove_content_type_header_for_presigning(request, **kwargs): # -> None:
    ...

BUILTIN_HANDLERS = ...
