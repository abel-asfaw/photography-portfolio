"""
This type stub file was generated by pyright.
"""

"""Binary Event Stream Decoding """
_PRELUDE_LENGTH = ...
_MAX_HEADERS_LENGTH = ...
_MAX_PAYLOAD_LENGTH = ...
class ParserError(Exception):
    """Base binary flow encoding parsing exception."""
    ...


class DuplicateHeader(ParserError):
    """Duplicate header found in the event."""
    def __init__(self, header) -> None:
        ...
    


class InvalidHeadersLength(ParserError):
    """Headers length is longer than the maximum."""
    def __init__(self, length) -> None:
        ...
    


class InvalidPayloadLength(ParserError):
    """Payload length is longer than the maximum."""
    def __init__(self, length) -> None:
        ...
    


class ChecksumMismatch(ParserError):
    """Calculated checksum did not match the expected checksum."""
    def __init__(self, expected, calculated) -> None:
        ...
    


class NoInitialResponseError(ParserError):
    """An event of type initial-response was not received.

    This exception is raised when the event stream produced no events or
    the first event in the stream was not of the initial-response type.
    """
    def __init__(self) -> None:
        ...
    


class DecodeUtils:
    """Unpacking utility functions used in the decoder.

    All methods on this class take raw bytes and return  a tuple containing
    the value parsed from the bytes and the number of bytes consumed to parse
    that value.
    """
    UINT8_BYTE_FORMAT = ...
    UINT16_BYTE_FORMAT = ...
    UINT32_BYTE_FORMAT = ...
    INT8_BYTE_FORMAT = ...
    INT16_BYTE_FORMAT = ...
    INT32_BYTE_FORMAT = ...
    INT64_BYTE_FORMAT = ...
    PRELUDE_BYTE_FORMAT = ...
    UINT_BYTE_FORMAT = ...
    @staticmethod
    def unpack_true(data): # -> tuple[Literal[True], Literal[0]]:
        """This method consumes none of the provided bytes and returns True.

        :type data: bytes
        :param data: The bytes to parse from. This is ignored in this method.

        :rtype: tuple
        :rtype: (bool, int)
        :returns: The tuple (True, 0)
        """
        ...
    
    @staticmethod
    def unpack_false(data): # -> tuple[Literal[False], Literal[0]]:
        """This method consumes none of the provided bytes and returns False.

        :type data: bytes
        :param data: The bytes to parse from. This is ignored in this method.

        :rtype: tuple
        :rtype: (bool, int)
        :returns: The tuple (False, 0)
        """
        ...
    
    @staticmethod
    def unpack_uint8(data): # -> tuple[Any, Literal[1]]:
        """Parse an unsigned 8-bit integer from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: (int, int)
        :returns: A tuple containing the (parsed integer value, bytes consumed)
        """
        ...
    
    @staticmethod
    def unpack_uint32(data): # -> tuple[Any, Literal[4]]:
        """Parse an unsigned 32-bit integer from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: (int, int)
        :returns: A tuple containing the (parsed integer value, bytes consumed)
        """
        ...
    
    @staticmethod
    def unpack_int8(data): # -> tuple[Any, Literal[1]]:
        """Parse a signed 8-bit integer from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: (int, int)
        :returns: A tuple containing the (parsed integer value, bytes consumed)
        """
        ...
    
    @staticmethod
    def unpack_int16(data): # -> tuple[Any, Literal[2]]:
        """Parse a signed 16-bit integer from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: tuple
        :rtype: (int, int)
        :returns: A tuple containing the (parsed integer value, bytes consumed)
        """
        ...
    
    @staticmethod
    def unpack_int32(data): # -> tuple[Any, Literal[4]]:
        """Parse a signed 32-bit integer from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: tuple
        :rtype: (int, int)
        :returns: A tuple containing the (parsed integer value, bytes consumed)
        """
        ...
    
    @staticmethod
    def unpack_int64(data): # -> tuple[Any, Literal[8]]:
        """Parse a signed 64-bit integer from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: tuple
        :rtype: (int, int)
        :returns: A tuple containing the (parsed integer value, bytes consumed)
        """
        ...
    
    @staticmethod
    def unpack_byte_array(data, length_byte_size=...): # -> tuple[Any, Any]:
        """Parse a variable length byte array from the bytes.

        The bytes are expected to be in the following format:
            [ length ][0 ... length bytes]
        where length is an unsigned integer represented in the smallest number
        of bytes to hold the maximum length of the array.

        :type data: bytes
        :param data: The bytes to parse from.

        :type length_byte_size: int
        :param length_byte_size: The byte size of the preceding integer that
        represents the length of the array. Supported values are 1, 2, and 4.

        :rtype: (bytes, int)
        :returns: A tuple containing the (parsed byte array, bytes consumed).
        """
        ...
    
    @staticmethod
    def unpack_utf8_string(data, length_byte_size=...): # -> tuple[Any, Any]:
        """Parse a variable length utf-8 string from the bytes.

        The bytes are expected to be in the following format:
            [ length ][0 ... length bytes]
        where length is an unsigned integer represented in the smallest number
        of bytes to hold the maximum length of the array and the following
        bytes are a valid utf-8 string.

        :type data: bytes
        :param bytes: The bytes to parse from.

        :type length_byte_size: int
        :param length_byte_size: The byte size of the preceding integer that
        represents the length of the array. Supported values are 1, 2, and 4.

        :rtype: (str, int)
        :returns: A tuple containing the (utf-8 string, bytes consumed).
        """
        ...
    
    @staticmethod
    def unpack_uuid(data): # -> tuple[Any, Literal[16]]:
        """Parse a 16-byte uuid from the bytes.

        :type data: bytes
        :param data: The bytes to parse from.

        :rtype: (bytes, int)
        :returns: A tuple containing the (uuid bytes, bytes consumed).
        """
        ...
    
    @staticmethod
    def unpack_prelude(data): # -> tuple[tuple[Any, ...], Literal[12]]:
        """Parse the prelude for an event stream message from the bytes.

        The prelude for an event stream message has the following format:
            [total_length][header_length][prelude_crc]
        where each field is an unsigned 32-bit integer.

        :rtype: ((int, int, int), int)
        :returns: A tuple of ((total_length, headers_length, prelude_crc),
        consumed)
        """
        ...
    


class MessagePrelude:
    """Represents the prelude of an event stream message."""
    def __init__(self, total_length, headers_length, crc) -> None:
        ...
    
    @property
    def payload_length(self):
        """Calculates the total payload length.

        The extra minus 4 bytes is for the message CRC.

        :rtype: int
        :returns: The total payload length.
        """
        ...
    
    @property
    def payload_end(self):
        """Calculates the byte offset for the end of the message payload.

        The extra minus 4 bytes is for the message CRC.

        :rtype: int
        :returns: The byte offset from the beginning of the event stream
        message to the end of the payload.
        """
        ...
    
    @property
    def headers_end(self): # -> int:
        """Calculates the byte offset for the end of the message headers.

        :rtype: int
        :returns: The byte offset from the beginning of the event stream
        message to the end of the headers.
        """
        ...
    


class EventStreamMessage:
    """Represents an event stream message."""
    def __init__(self, prelude, headers, payload, crc) -> None:
        ...
    
    def to_response_dict(self, status_code=...): # -> dict[str, Any]:
        ...
    


class EventStreamHeaderParser:
    """Parses the event headers from an event stream message.

    Expects all of the header data upfront and creates a dictionary of headers
    to return. This object can be reused multiple times to parse the headers
    from multiple event stream messages.
    """
    _HEADER_TYPE_MAP = ...
    def __init__(self) -> None:
        ...
    
    def parse(self, data): # -> dict[Any, Any]:
        """Parses the event stream headers from an event stream message.

        :type data: bytes
        :param data: The bytes that correspond to the headers section of an
        event stream message.

        :rtype: dict
        :returns: A dictionary of header key, value pairs.
        """
        ...
    


class EventStreamBuffer:
    """Streaming based event stream buffer

    A buffer class that wraps bytes from an event stream providing parsed
    messages as they become available via an iterable interface.
    """
    def __init__(self) -> None:
        ...
    
    def add_data(self, data): # -> None:
        """Add data to the buffer.

        :type data: bytes
        :param data: The bytes to add to the buffer to be used when parsing
        """
        ...
    
    def next(self): # -> EventStreamMessage:
        """Provides the next available message parsed from the stream

        :rtype: EventStreamMessage
        :returns: The next event stream message
        """
        ...
    
    def __next__(self): # -> EventStreamMessage:
        ...
    
    def __iter__(self): # -> Self:
        ...
    


class EventStream:
    """Wrapper class for an event stream body.

    This wraps the underlying streaming body, parsing it for individual events
    and yielding them as they come available through the iterator interface.

    The following example uses the S3 select API to get structured data out of
    an object stored in S3 using an event stream.

    **Example:**
    ::
        from botocore.session import Session

        s3 = Session().create_client('s3')
        response = s3.select_object_content(
            Bucket='bucketname',
            Key='keyname',
            ExpressionType='SQL',
            RequestProgress={'Enabled': True},
            Expression="SELECT * FROM S3Object s",
            InputSerialization={'CSV': {}},
            OutputSerialization={'CSV': {}},
        )
        # This is the event stream in the response
        event_stream = response['Payload']
        end_event_received = False
        with open('output', 'wb') as f:
            # Iterate over events in the event stream as they come
            for event in event_stream:
                # If we received a records event, write the data to a file
                if 'Records' in event:
                    data = event['Records']['Payload']
                    f.write(data)
                # If we received a progress event, print the details
                elif 'Progress' in event:
                    print(event['Progress']['Details'])
                # End event indicates that the request finished successfully
                elif 'End' in event:
                    print('Result is complete')
                    end_event_received = True
        if not end_event_received:
            raise Exception("End event not received, request incomplete.")
    """
    def __init__(self, raw_stream, output_shape, parser, operation_name) -> None:
        ...
    
    def __iter__(self): # -> Generator[Any, Any, None]:
        ...
    
    def get_initial_response(self): # -> EventStreamMessage:
        ...
    
    def close(self): # -> None:
        """Closes the underlying streaming body."""
        ...
    


