"""
This type stub file was generated by pyright.
"""

from enum import Enum
from typing import NamedTuple
from botocore.utils import lru_cache_weakref

"""
NOTE: All classes and functions in this module are considered private and are
subject to abrupt breaking changes. Please do not use them directly.

To view the raw JSON that the objects in this module represent, please
go to any `endpoint-rule-set.json` file in /botocore/data/<service>/<api version>/
or you can look at the test files in /tests/unit/data/endpoints/valid-rules/
"""
logger = ...
TEMPLATE_STRING_RE = ...
GET_ATTR_RE = ...
VALID_HOST_LABEL_RE = ...
CACHE_SIZE = ...
ARN_PARSER = ...
STRING_FORMATTER = ...
class RuleSetStandardLibrary:
    """Rule actions to be performed by the EndpointProvider."""
    def __init__(self, partitions_data) -> None:
        ...
    
    def is_func(self, argument): # -> bool:
        """Determine if an object is a function object.

        :type argument: Any
        :rtype: bool
        """
        ...
    
    def is_ref(self, argument): # -> bool:
        """Determine if an object is a reference object.

        :type argument: Any
        :rtype: bool
        """
        ...
    
    def is_template(self, argument): # -> bool:
        """Determine if an object contains a template string.

        :type argument: Any
        :rtpe: bool
        """
        ...
    
    def resolve_template_string(self, value, scope_vars): # -> str:
        """Resolve and inject values into a template string.

        :type value: str
        :type scope_vars: dict
        :rtype: str
        """
        ...
    
    def resolve_value(self, value, scope_vars): # -> Any | str:
        """Return evaluated value based on type.

        :type value: Any
        :type scope_vars: dict
        :rtype: Any
        """
        ...
    
    def convert_func_name(self, value): # -> LiteralString | str:
        """Normalize function names.

        :type value: str
        :rtype: str
        """
        ...
    
    def call_function(self, func_signature, scope_vars): # -> Any:
        """Call the function with the resolved arguments and assign to `scope_vars`
        when applicable.

        :type func_signature: dict
        :type scope_vars: dict
        :rtype: Any
        """
        ...
    
    def is_set(self, value): # -> bool:
        """Evaluates whether a value is set.

        :type value: Any
        :rytpe: bool
        """
        ...
    
    def get_attr(self, value, path): # -> None:
        """Find an attribute within a value given a path string. The path can contain
        the name of the attribute and an index in brackets. A period separating attribute
        names indicates the one to the right is nested. The index will always occur at
        the end of the path.

        :type value: dict or list
        :type path: str
        :rtype: Any
        """
        ...
    
    def format_partition_output(self, partition):
        ...
    
    def is_partition_match(self, region, partition): # -> bool:
        ...
    
    def aws_partition(self, value):
        """Match a region string to an AWS partition.

        :type value: str
        :rtype: dict
        """
        ...
    
    def aws_parse_arn(self, value): # -> dict[str, Any] | None:
        """Parse and validate string for ARN components.

        :type value: str
        :rtype: dict
        """
        ...
    
    def is_valid_host_label(self, value, allow_subdomains): # -> bool:
        """Evaluates whether a value is a valid host label per
        RFC 1123. If allow_subdomains is True, split on `.` and validate
        each component separately.

        :type value: str
        :type allow_subdomains: bool
        :rtype: bool
        """
        ...
    
    def string_equals(self, value1, value2):
        """Evaluates two string values for equality.

        :type value1: str
        :type value2: str
        :rtype: bool
        """
        ...
    
    def uri_encode(self, value): # -> str | None:
        """Perform percent-encoding on an input string.

        :type value: str
        :rytpe: str
        """
        ...
    
    def parse_url(self, value): # -> dict[str, Any] | None:
        """Parse a URL string into components.

        :type value: str
        :rtype: dict
        """
        ...
    
    def boolean_equals(self, value1, value2): # -> bool:
        """Evaluates two boolean values for equality.

        :type value1: bool
        :type value2: bool
        :rtype: bool
        """
        ...
    
    def is_ascii(self, value): # -> bool:
        """Evaluates if a string only contains ASCII characters.

        :type value: str
        :rtype: bool
        """
        ...
    
    def substring(self, value, start, stop, reverse): # -> str | None:
        """Computes a substring given the start index and end index. If `reverse` is
        True, slice the string from the end instead.

        :type value: str
        :type start: int
        :type end: int
        :type reverse: bool
        :rtype: str
        """
        ...
    
    def aws_is_virtual_hostable_s3_bucket(self, value, allow_subdomains): # -> bool:
        """Evaluates whether a value is a valid bucket name for virtual host
        style bucket URLs. To pass, the value must meet the following criteria:
        1. is_valid_host_label(value) is True
        2. length between 3 and 63 characters (inclusive)
        3. does not contain uppercase characters
        4. is not formatted as an IP address

        If allow_subdomains is True, split on `.` and validate
        each component separately.

        :type value: str
        :type allow_subdomains: bool
        :rtype: bool
        """
        ...
    


RuleSetStandardLibary = RuleSetStandardLibrary
class BaseRule:
    """Base interface for individual endpoint rules."""
    def __init__(self, conditions, documentation=...) -> None:
        ...
    
    def evaluate(self, scope_vars, rule_lib):
        ...
    
    def evaluate_conditions(self, scope_vars, rule_lib): # -> bool:
        """Determine if all conditions in a rule are met.

        :type scope_vars: dict
        :type rule_lib: RuleSetStandardLibrary
        :rtype: bool
        """
        ...
    


class RuleSetEndpoint(NamedTuple):
    """A resolved endpoint object returned by a rule."""
    url: str
    properties: dict
    headers: dict
    ...


class EndpointRule(BaseRule):
    def __init__(self, endpoint, **kwargs) -> None:
        ...
    
    def evaluate(self, scope_vars, rule_lib): # -> RuleSetEndpoint | None:
        """Determine if conditions are met to provide a valid endpoint.

        :type scope_vars: dict
        :rtype: RuleSetEndpoint
        """
        ...
    
    def resolve_properties(self, properties, scope_vars, rule_lib): # -> list[list[Any] | dict[Any, Any] | Any] | dict[Any, Any]:
        """Traverse `properties` attribute, resolving any template strings.

        :type properties: dict/list/str
        :type scope_vars: dict
        :type rule_lib: RuleSetStandardLibrary
        :rtype: dict
        """
        ...
    
    def resolve_headers(self, scope_vars, rule_lib): # -> dict[Any, Any]:
        """Iterate through headers attribute resolving all values.

        :type scope_vars: dict
        :type rule_lib: RuleSetStandardLibrary
        :rtype: dict
        """
        ...
    


class ErrorRule(BaseRule):
    def __init__(self, error, **kwargs) -> None:
        ...
    
    def evaluate(self, scope_vars, rule_lib): # -> None:
        """If an error rule's conditions are met, raise an error rule.

        :type scope_vars: dict
        :type rule_lib: RuleSetStandardLibrary
        :rtype: EndpointResolutionError
        """
        ...
    


class TreeRule(BaseRule):
    """A tree rule is non-terminal meaning it will never be returned to a provider.
    Additionally this means it has no attributes that need to be resolved.
    """
    def __init__(self, rules, **kwargs) -> None:
        ...
    
    def evaluate(self, scope_vars, rule_lib): # -> Any | None:
        """If a tree rule's conditions are met, iterate its sub-rules
        and return first result found.

        :type scope_vars: dict
        :type rule_lib: RuleSetStandardLibrary
        :rtype: RuleSetEndpoint/EndpointResolutionError
        """
        ...
    


class RuleCreator:
    endpoint = EndpointRule
    error = ErrorRule
    tree = TreeRule
    @classmethod
    def create(cls, **kwargs): # -> Any:
        """Create a rule instance from metadata.

        :rtype: TreeRule/EndpointRule/ErrorRule
        """
        ...
    


class ParameterType(Enum):
    """Translation from `type` attribute to native Python type."""
    string = str
    boolean = bool


class ParameterDefinition:
    """The spec of an individual parameter defined in a RuleSet."""
    def __init__(self, name, parameter_type, documentation=..., builtIn=..., default=..., required=..., deprecated=...) -> None:
        ...
    
    def validate_input(self, value): # -> None:
        """Perform base validation on parameter input.

        :type value: Any
        :raises: EndpointParametersError
        """
        ...
    
    def process_input(self, value):
        """Process input against spec, applying default if value is None."""
        ...
    


class RuleSet:
    """Collection of rules to derive a routable service endpoint."""
    def __init__(self, version, parameters, rules, partitions, documentation=...) -> None:
        ...
    
    def process_input_parameters(self, input_params): # -> None:
        """Process each input parameter against its spec.

        :type input_params: dict
        """
        ...
    
    def evaluate(self, input_parameters): # -> Any | None:
        """Evaluate input parameters against rules returning first match.

        :type input_parameters: dict
        """
        ...
    


class EndpointProvider:
    """Derives endpoints from a RuleSet for given input parameters."""
    def __init__(self, ruleset_data, partition_data) -> None:
        ...
    
    @lru_cache_weakref(maxsize=CACHE_SIZE)
    def resolve_endpoint(self, **input_parameters): # -> Any:
        """Match input parameters to a rule.

        :type input_parameters: dict
        :rtype: RuleSetEndpoint
        """
        ...
    


